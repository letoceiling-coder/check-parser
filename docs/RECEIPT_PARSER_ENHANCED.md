# Метод «Улучшенный»: определение суммы и даты из чеков

Подробное описание логики метода **Улучшенный (pdftotext, контекст даты, оплачено/списано, уверенность)** — как получается текст чека, как извлекаются дата и сумма и как считается уверенность (confidence).

---

## 1. Место метода в системе

| Параметр | Значение |
|----------|----------|
| Идентификатор в настройках | `receipt_parser_method = 'enhanced'` |
| Константа в коде | `BotSettings::PARSER_ENHANCED` |
| Основной класс парсинга | `App\Services\ReceiptParser` |
| Предобработка текста | `App\Services\ReceiptTextPreprocessor` |

Метод вызывается только когда в настройках розыгрыша выбран «Улучшенный» или «Интеллектуальный»; в последнем случае при низкой уверенности дополнительно вызывается AI (см. `docs/RECEIPT_AI_LLM.md`).

---

## 2. Получение текста чека (до парсера)

Парсеру передаётся уже извлечённый текст. Источник текста зависит от типа файла и порядка попыток.

### 2.1. PDF: приоритет pdftotext (без OCR)

Если загружен **PDF** и метод парсинга — улучшенный или интеллектуальный:

1. Вызывается **`extractTextFromTextPdf($pdfFullPath)`**.
2. Команда: `pdftotext -layout -enc UTF-8 <файл> -` (вывод в stdout).
3. Требования: на сервере должен быть установлен **poppler-utils** (утилита `pdftotext`).
4. Условие успеха: вывод не пустой и длина текста ≥ 100 символов.
5. Если успех — этот текст сразу передаётся в `parsePaymentAmount(..., true)` (улучшенный режим). OCR **не вызывается**.

**Зачем:** Текстовые PDF (чеки, сформированные банком в приложении) дают идеальный текст без ошибок распознавания. Сканы PDF обрабатываются дальше через конвертацию в изображение и OCR.

### 2.2. PDF: если pdftotext не сработал — изображение и OCR

Если pdftotext вернул пустой или короткий текст:

1. PDF конвертируется в изображение (например, Imagick, 600 DPI).
2. Запускается цепочка OCR-методов (remote Tesseract, локальный Tesseract, OCR.space, Google Vision и т.д.).
3. Выбирается первый результат с достаточным объёмом и качеством текста (длина, доля «читаемых» символов, наличие ключевых слов чека).
4. Этот текст передаётся в `parsePaymentAmount($extractedText, $useEnhanced, ...)`.

### 2.3. Не PDF (например, фото чека)

Файл сразу считается изображением; выполняется только OCR (как в п. 2.2), затем вызов `parsePaymentAmount` с флагом улучшенного режима.

Итог: на вход **ReceiptParser** всегда приходит одна строка — текст чека (из pdftotext или OCR).

---

## 3. Предобработка текста (ReceiptTextPreprocessor)

Перед разбором текст обрабатывается методом **`preprocessForNumbers($text)`** (регистр не меняется, чтобы не ломать контекст для regex).

| Шаг | Действие | Назначение |
|-----|----------|------------|
| 1 | Замена `\r\n`, `\r` на `\n` | Единые переносы строк |
| 2 | Замена неразрывных и прочих спецпробелов (`\x{00A0}` и др.) на обычный пробел | Корректный поиск «слово + число» |
| 3 | Схлопывание повторяющихся пробелов/табов | Стабильная длина окон для контекста |
| 4 | OCR: буквы «О», «о», «O», «o» рядом с цифрами и ₽/руб → цифра `0` | «10 ооо ₽» → «10 000 ₽», «1ооо» → «1000» |
| 5 | OCR: латинская `l` рядом с цифрами → `1` | «10l0» → «1010» |
| 6 | Запятая в дробной части числа: `(\d),(\d{2})` → `\1.\2` | «10,50» → «10.50» |

После этого сохраняются две копии: исходная (для regex) и в нижнем регистре (`$textLower`) для поиска ключевых слов и определения банка.

---

## 4. Общая схема работы ReceiptParser

Метод **`parse()`** возвращает один ассоциативный массив. Порядок шагов:

1. **Извлечение даты** — `extractDate()`.
2. **Извлечение суммы** — `extractAmount()`.
3. **Определение банка** — `extractBank()` (опционально, по `config/bank_checks.php`).
4. **Расчёт уверенности** — `calculateConfidence($date, $amount)`.

В результат попадают только не-null значения; поле `raw_text` — первые 500 символов обработанного текста (для отладки).

---

## 5. Извлечение даты (extractDate)

### 5.1. Кандидаты дат (findDateCandidates)

Ищутся все подходящие даты по фиксированному набору regex (порядок важен):

| Паттерн | Пример | Группы (день, месяц, год, час, мин, сек) |
|---------|--------|------------------------------------------|
| `DD.MM.YYYY HH:MM:SS` или `HH:MM` | 03.02.2026 10:14:31 | 1,2,3,4,5,6 |
| `DD.MM.YYYY HH:MM` | 03.02.2026 10:14 | 1,2,3,4,5,— |
| `DD.MM.YYYY` | 03.02.2026 | 1,2,3,—,—,— |
| `DD.MM.YY` с опциональным временем | 03.02.26 10:14 | 1,2,3,4,5,— (год дополняется до 20xx) |
| `YYYY-MM-DD HH:MM` | 2026-02-03 10:14 | 3,2,1,4,5,— (переставленные группы) |

Разделители даты: точка, слэш, дефис. Для каждого совпадения:

- Проверка: день 1–31, месяц 1–12, год от `YEAR_MIN` (2018) до текущего. Двузначный год превращается в 2000 + YY.
- Дедупликация по ключу `"день-месяц-год"`.
- Для кандидата сохраняются: нормализованная дата `YYYY-MM-DD`, позиция в тексте, время (если есть), сниппет ±80 символов вокруг, флаги:
  - **has_data_kw** — в сниппете есть хотя бы одно из слов: «дата», «операции», «операци», «время», «чек», «операция»;
  - **has_time** — в сниппете есть подстрока вида `ЧЧ:ММ`;
  - **in_first_20pct** — позиция в первых 20% текста.

### 5.2. Фильтрация и приоритет кандидатов

- **Валидность по контексту:** кандидат считается подходящим, если выполняется хотя бы одно:
  - он в первых 20% текста (`in_first_20pct`);
  - в сниппете есть контекстное слово даты (`has_data_kw`);
  - в сниппете есть время (`has_time`).
- Если после этого фильтра никого не осталось — в отбор попадают все кандидаты (берём лучшего по приоритету).

Сортировка (выбор «лучшей» даты):

1. Выше в тексте (меньше `pos`) — выше приоритет.
2. При равной позиции — предпочтительнее кандидат с временем.
3. Далее — предпочтительнее наличие контекстного слова («дата» и т.п.).

Результат: одна строка вида `YYYY-MM-DD` или `YYYY-MM-DD HH:MM` (или `HH:MM:SS`).

### 5.3. Формат «N месяца ГГГГ» (tryRussianMonthDate)

Если ни один кандидат по regex не найден, вызывается **tryRussianMonthDate()**:

- Regex: `(\d{1,2})\s+(января|февраля|...|декабря)\s+(\d{4})(?:\s+(?:в\s+)?(\d{1,2}):(\d{2}))?`.
- Пример: «3 февраля 2026», «3 февраля 2026 в 14:38».
- Год проверяется так же (от 2018 до текущего). Возвращается дата в формате `YYYY-MM-DD` или с добавлением времени.

Если и здесь совпадений нет — дата остаётся `null`.

---

## 6. Извлечение суммы (extractAmount)

Сумма ищется **только в связке с ключевыми словами**. Числа «просто так» в тексте не считаются суммой операции.

### 6.1. Ключевые слова (приоритет сверху вниз)

```text
итого, сумма, всего, оплачено, списано, к оплате, исполнено,
сумма перевода, сумма операции, перевод на карту
```

Чем раньше слово в списке, тем выше базовый приоритет при выборе между несколькими найденными суммами.

### 6.2. Где ищем числа

- **По окну после ключа:** для каждого вхождения ключевого слова берётся окно **120 символов** после него (текст предварительно схлопнут в одну строку). В этом окне ищутся числа по regex сумм.
- **По строкам:** текст разбивается на строки; если в строке есть любое из ключевых слов, в этой строке ищутся числа по тому же regex.

Оба прохода заполняют общий массив кандидатов `$foundByKeyword` с полями: `amount`, `keyword`, `priority`, `hasCurrency` (есть ли рядом символ рубля/«руб»).

### 6.3. Regex числа (AMOUNT_REGEX)

Допускаются форматы:

- Целое или с копейками, с пробелами как разделителями тысяч: `1 234 567,89` или `65 100,00`.
- Европейский формат тысяч: `1.234.567,89` или `10.000`.
- Обычная запятая/точка для копеек: `1234,56` или `1234.56`.

В конце числа допускается необязательный суффикс: пробелы и символы `₽`, `Р`, `р`, `P`, `p`, `руб`, `р.` и т.п.

### 6.4. Исключения: когда число не считается суммой

**Плохой префикс (в ~28 символах перед числом):**  
Если в этом фрагменте встречаются слова: «комиссия», «комисс», «сбор за», «сбор:», «остаток», «в т.ч.», «в т ч», «включая комиссию», «в том числе», «платеж за услуг», «счет», «счёт», «номер кошелька», «кошелька», «номер карты», «карты» — кандидат отбрасывается.

**Плохой общий контекст (в окне/строке):**  
Если есть слова: «идентификатор», «инн», «бик», «кпп», «авторизац» — кандидат отбрасывается.

**Специально для «итого»/«всего»:**  
Если в том же контексте есть «комиссия» или «в т.ч.»/«в т ч» — кандидат отбрасывается (чтобы не принять итог «в т.ч. комиссия» за сумму операции).

**Похоже на номер карты:**  
В 15 символах после числа проверяется: если есть `**` или число короткое (≤3 цифры) и сразу после идут цифры — считается частью номера карты/кошелька, кандидат отбрасывается.

### 6.5. Нормализация и проверка числа (normalizeAndValidateAmount)

- Убрать пробелы и неразрывные пробелы.
- Запятая → точка.
- Лишние точки (как разделители тысяч): удаляется точка, за которой ещё есть точка (европейский формат «10.000» → «10000»).
- Проверки: значение числовое, строго больше 0, не более 10 000 000, длина строки числа не более 10 символов.

Если проверка не пройдена — кандидат не добавляется.

### 6.6. Фильтр при наличии комиссии (filterSmallCommissionAmounts)

Если в тексте чека встречается «комиссия» или «комисс»:

- Вычисляется максимальная сумма среди кандидатов.
- Если эта сумма ≥ 1000 — из кандидатов удаляются все суммы **< 300**, кроме самой максимальной (чтобы не принять комиссию за основную сумму).

Если после фильтра кандидатов не остаётся — возвращается `null`.

### 6.7. Выбор одной суммы (сортировка и проверка)

При наличии в тексте комиссии повышается приоритет ключевых слов, указывающих на саму операцию, перед «итого/всего»:

- Базовые ключи: «сумма перевода», «оплачено», «списано», «сумма операции», «перевод на карту».
- «Итоговые» ключи: «итого», «всего».

Сортировка кандидатов:

1. При наличии комиссии: кандидаты с базовым ключом выше кандидатов с «итого»/«всего».
2. Наличие валюты (₽/руб) — выше приоритет.
3. Базовый приоритет ключа (порядок в `AMOUNT_KEYWORDS`).
4. При равенстве — больше сумма выше.

Берётся первый элемент. Дополнительная проверка: если найдено **4 и более разных сумм** и выбранная сумма совпадает с **минимальной** среди них — результат отклоняется (`null`), чтобы не принять комиссию или остаток.

Итог: одно значение `float` или `null`.

---

## 7. Определение банка (extractBank)

- Используется конфиг **`config/bank_checks.php`**: секции `banks` и `detection_order`.
- По порядку из `detection_order` проверяется каждый банк (кроме `default`): если в тексте (в нижнем регистре) встречается любое из `detect_keywords` этого банка — возвращается код банка (например, `sber`, `tinkoff`).
- Если ни один банк не подошёл — `null`. Поле `bank_code` в результате парсера опционально и может использоваться для будущей банк-специфичной логики.

---

## 8. Расчёт уверенности (calculateConfidence)

Итоговое значение **parsing_confidence** — число от 0 до 1.

| Условие | Добавление к score |
|--------|---------------------|
| Дата найдена (любым способом) | +0.4 |
| Сумма найдена **по ключевому слову** (итого/оплачено/списано и т.д.) | +0.4 |
| Сумма найдена, но не по ключевому слову | +0.2 |
| И дата, и сумма найдены, при этом кандидатов даты не больше одного | +0.2 |

Итоговая сумма ограничивается 1.0 и округляется до двух знаков.

**Понижение при нескольких датах:**  
Если кандидатов дат больше одного и рассчитанный confidence был бы ≥ 0.7, он принудительно устанавливается в **0.65** (несколько дат считаются признаком неоднозначности).

В коде флаг «сумма по ключевому слову» задаётся в `extractAmount()` (`$this->amountFoundByKeyword`); количество кандидатов дат сохраняется в `extractDate()` (`$this->dateCandidatesCount`).

---

## 9. Формат результата parse()

Возвращаемый массив (только не-null поля):

| Ключ | Тип | Описание |
|------|-----|----------|
| `date` | string\|null | Дата в формате `YYYY-MM-DD` или `YYYY-MM-DD HH:MM[:SS]` |
| `amount` | float\|null | Сумма в рублях |
| `sum` | float\|null | Дублирует `amount` |
| `currency` | string | Всегда `RUB` |
| `bank_code` | string\|null | Код банка из `bank_checks` или null |
| `parsing_confidence` | float | Уверенность 0…1 |
| `raw_text` | string | Первые 500 символов обработанного текста |

Поле `source` в этом методе не выставляется — его при необходимости проставляет вызывающий код (например, `pdf`, `ocr` или `ai` после fallback).

---

## 10. Использование в parsePaymentAmount (контроллер)

- При **улучшенном** или **интеллектуальном** методе создаётся `new ReceiptParser($text)`, вызывается `parse()`.
- Если в результате есть и `amount`, и `date`, и **parsing_confidence ≥ 0.9** — этот результат сразу возвращается (без вызова классического парсера и без AI).
- Если confidence < 0.9 или чего-то не хватает — при методе «Интеллектуальный» и включённом AI вызывается AI fallback; иначе выполняется классический разбор (legacy) по тому же тексту.

Классический парсер (regex по всему тексту, без контекста ключевых слов и без confidence) описан в другой логике и в этой документации не разбирается.

---

## 11. Краткая сводка

| Этап | Что делается |
|------|------------------|
| Вход | Текст чека (из pdftotext для текстового PDF или из OCR для сканов/фото). |
| Предобработка | Нормализация пробелов и переносов, замена OCR-ошибок (О→0, l→1), запятая в дробях. |
| Дата | Все кандидаты по regex → фильтр по контексту (первые 20% / слова «дата»/«время»/«операции» / наличие времени) → сортировка по позиции, времени, контексту → одна дата; запасной вариант — «N месяца ГГГГ». |
| Сумма | Только в окрестности ключевых слов (итого, оплачено, списано и др.) → исключение плохого префикса/контекста и похожести на карту → нормализация числа и диапазон 0 < x ≤ 10M → при комиссии отсев малых сумм и приоритет «оплачено»/«списано» над «итого» → одна сумма или null. |
| Банк | По ключевым словам из `config/bank_checks.php`. |
| Confidence | 0.4 за дату + 0.4 за сумму по ключу (или 0.2 без ключа) + 0.2 за единственную дату и сумму; при нескольких датах — ограничение сверху 0.65. |

Документ описывает только улучшенный метод; интеллектуальный (с AI) и классический методы описаны в `docs/RECEIPT_AI_LLM.md` и в коде legacy-парсера соответственно.
