# Метод определения суммы и даты из чеков: интеллектуальный (LLM)

Документация по **дополнительному** методу извлечения оплаченной суммы и даты операции из текста чека с помощью LLM. Метод работает как **fallback**: используется только при недостаточной уверенности основного парсера или отсутствии данных.

---

## 1. Назначение и место в пайплайне

| Уровень | Описание |
|--------|----------|
| **Вход** | Очищенный текст чека (из PDF через pdftotext или из OCR: Tesseract, Google Vision и др.) |
| **Основной парсер** | `ReceiptParser` (улучшенный режим): контекст даты, маркеры «оплачено»/«списано», оценка уверенности |
| **Условие вызова AI** | Метод парсинга = `enhanced_ai` **и** либо `parsing_confidence < 0.9`, либо сумма/дата не найдены |
| **AI-метод** | `AIReceiptExtractor`: отправка текста в LLM, разбор JSON, валидация, возврат результата с `source = 'ai'` |
| **Итог** | Результат с полем `source`: `ocr` \| `pdf` \| `ai` |

Схема:

```
PDF/изображение чека
   → OCR или pdftotext
   → Текст чека
   → ReceiptParser (улучшенный)
   → confidence ≥ 0.9 и есть сумма и дата? → результат (source: pdf/ocr)
   → иначе при методе "Интеллектуальный" и включённом AI:
        → AIReceiptExtractor → LLM → JSON
        → валидация (сумма, дата, confidence ≥ 0.85)
        → результат (source: ai) или переход к классическому парсеру
```

Метод **не заменяет** существующую логику: классический и улучшенный парсеры работают как раньше. Добавлен только вариант «Интеллектуальный» и вызов LLM при необходимости.

---

## 2. Компоненты

### 2.1. Сервис: `App\Services\Receipt\AIReceiptExtractor`

- **Файл:** `app/Services/Receipt/AIReceiptExtractor.php`
- **Создание:** через `AIReceiptExtractor::fromConfig()` (читает `config/receipt_ai.php` и env).
- **Публичный метод:** `extract(string $rawText, array $context = []): AIReceiptExtractorResult`

**Вход:**

- `$rawText` — текст чека (обрезается до 6000 символов; при длине &lt; 50 возвращается пустой результат).
- `$context` (необязательно):
  - `previous_amount` — сумма из основного парсера (если есть);
  - `previous_date` — дата из основного парсера (если есть);
  - `bank_hint` — подсказка по банку (зарезервировано на будущее).

**Выход:** объект `AIReceiptExtractorResult` (см. ниже).

### 2.2. DTO: `App\Services\Receipt\AIReceiptExtractorResult`

- **Файл:** `app/Services/Receipt/AIReceiptExtractorResult.php`
- **Поля:** `amount` (float|null), `date` (string|null, Y-m-d), `currency`, `confidence` (0..1), `source` (= `'ai'`).
- **Методы:**
  - `toArray()` — массив для подстановки в общий ответ парсера (`amount`, `date`, `sum`, `currency`, `parsing_confidence`, `source`).
  - `isValid()` — `true`, если `confidence >= 0.85` и хотя бы одно из `amount` или `date` задано.
  - `empty()` — статический конструктор «пустого» результата (null, null, RUB, 0.0).

Использование результата в коде: только при `$result->isValid()` итог AI подставляется в ответ; иначе используется основной или классический парсер.

---

## 3. LLM: API и промпты

### 3.1. Протокол

- Используется **HTTP API в формате OpenAI Chat Completions** (или совместимый прокси).
- Запрос: POST на `config('receipt_ai.api_url')` с заголовком `Authorization: Bearer <api_key>`.
- Тело: `model`, `max_tokens`, `messages` (system + user), `temperature: 0.1`.

Отдельный SDK не используется — только `Illuminate\Support\Facades\Http`. Подойдёт любой endpoint, совместимый с форматом OpenAI (в т.ч. прокси к другим моделям).

### 3.2. System prompt (роль модели)

Модели задаётся роль «только JSON, без пояснений»:

```text
Ты — специализированный финансовый парсер банковских чеков Российской Федерации. Твоя задача — точно и осторожно извлекать итоговую оплаченную сумму и дату операции из текста чека. Ты НЕ ассистент и НЕ объясняешь решения. Ты возвращаешь ТОЛЬКО валидный JSON, строго по заданной схеме. Любой текст вне JSON запрещён.
```

### 3.3. User prompt (задача + текст чека)

В теле запроса в сообщении `user` передаётся шаблон, в котором плейсхолдер `{{CHECK_TEXT}}` заменяется на фактический текст чека (до 6000 символов):

```text
Проанализируй текст банковского чека ниже и извлеки итоговую оплаченную сумму и дату операции.

ПРАВИЛА:
1. Итоговая сумма — это фактически списанная сумма, а не комиссия, бонусы или предварительный расчёт.
2. Если в чеке несколько сумм, приоритет имеют поля: «Итого», «Списано», «Оплачено», «Сумма операции».
3. Если присутствует НДС — он НЕ является итоговой суммой.
4. Дата операции — это дата проведения платежа, а не дата формирования чека.
5. Время операции игнорируй.
6. Если данные противоречивы или неочевидны — верни null.
7. Оцени уверенность извлечения (confidence) от 0 до 1.

ТЕКСТ ЧЕКА:
<<<
{{CHECK_TEXT}}
>>>

ФОРМАТ ОТВЕТА (СТРОГО):
{
  "amount": number | null,
  "date": "YYYY-MM-DD" | null,
  "currency": "RUB",
  "confidence": number
}
```

### 3.4. Ожидаемый ответ LLM

Допустим только один JSON-объект в ответе. Текст до/после JSON (в т.ч. обёртка в markdown-блоки `` ```json ``) отбрасывается; парсится только содержимое объекта.

**Пример успешного ответа:**

```json
{
  "amount": 4980.00,
  "date": "2026-01-12",
  "currency": "RUB",
  "confidence": 0.93
}
```

**Пример при сомнительных данных:**

```json
{
  "amount": null,
  "date": null,
  "currency": "RUB",
  "confidence": 0.42
}
```

Если ответ не JSON или структура не совпадает — результат считается пустым (возвращается `AIReceiptExtractorResult::empty()`).

---

## 4. Валидация после ответа LLM

Перед тем как результат AI считается пригодным к использованию, на backend выполняется проверка:

| Поле | Правило | При нарушении |
|------|--------|----------------|
| **amount** | Число, строго &gt; 0 и ≤ 10 000 000; округление до 2 знаков после запятой | В результат подставляется `null` (поле не используется) |
| **date** | Строка даты, разбираемая PHP; дата не в будущем; не старше 2 лет (настраивается в config) | В результат подставляется `null` |
| **confidence** | 0 ≤ confidence ≤ 1 | Ограничивается диапазоном; для принятия решения используется порог 0.85 |

Результат AI **принимается** только если `isValid()` возвращает `true`, т.е.:

- `confidence >= 0.85` (порог задаётся в `config('receipt_ai.validation.confidence_threshold')`);
- хотя бы одно из полей `amount` или `date` не null после валидации.

Иначе итог LLM отбрасывается и используется основной/классический парсер или запрос подтверждения у пользователя.

---

## 5. Конфигурация

### 5.1. Файл `config/receipt_ai.php`

| Ключ | Значение по умолчанию | Описание |
|------|----------------------|----------|
| `enabled` | `env('RECEIPT_AI_ENABLED', false)` | Включение/выключение вызова LLM |
| `api_url` | `env('OPENAI_API_URL', 'https://api.openai.com/v1/chat/completions')` | URL API чата (OpenAI или совместимый) |
| `api_key` | `env('OPENAI_API_KEY', '')` | API-ключ (Bearer) |
| `model` | `env('OPENAI_MODEL', 'gpt-4o-mini')` | Имя модели |
| `max_tokens` | `env('RECEIPT_AI_MAX_TOKENS', 256)` | Лимит токенов ответа |
| `timeout` | `env('RECEIPT_AI_TIMEOUT', 15)` | Таймаут HTTP-запроса (секунды) |
| `validation.amount_min` | 0 | Минимальная допустимая сумма |
| `validation.amount_max` | 10_000_000 | Максимальная допустимая сумма |
| `validation.confidence_threshold` | 0.85 | Порог уверенности для принятия результата (используется в `isValid()`) |
| `validation.date_max_years_ago` | 2 | Максимальный возраст даты (лет от текущей) |

### 5.2. Переменные окружения (.env)

Минимальный набор для работы метода:

```env
RECEIPT_AI_ENABLED=true
OPENAI_API_KEY=sk-...
```

Опционально:

```env
OPENAI_API_URL=https://api.openai.com/v1/chat/completions
OPENAI_MODEL=gpt-4o-mini
RECEIPT_AI_MAX_TOKENS=256
RECEIPT_AI_TIMEOUT=15
```

Если `RECEIPT_AI_ENABLED=false` или не задан `OPENAI_API_KEY`, метод не вызывается (даже при выборе «Интеллектуальный» в настройках бота).

---

## 6. Включение и отключение

1. **Глобально:**  
   - Выключить: `RECEIPT_AI_ENABLED=false` или не задавать ключ.  
   - Включить: `RECEIPT_AI_ENABLED=true` и задать `OPENAI_API_KEY`.

2. **По боту:**  
   В настройках розыгрыша (админка) в поле «Метод определения суммы и даты из чеков» выбирается один из вариантов:
   - **Классический** — только текущий regex/паттерны.
   - **Улучшенный** — ReceiptParser без вызова LLM.
   - **Интеллектуальный** — улучшенный парсер + при необходимости вызов LLM (fallback).

При выборе «Интеллектуальный» LLM вызывается только если включён `receipt_ai.enabled` и `AIReceiptExtractor::fromConfig()->isConfigured()` возвращает `true` (заполнены `api_url` и `api_key`).

---

## 7. Логирование

Логируются только обезличенные/агрегированные данные, без полного текста чека и персональных данных:

- **При слишком коротком тексте:** уровень debug, длина текста.
- **При ошибке API:** уровень warning, HTTP-статус, короткий превью тела ответа (до 200 символов).
- **При невалидном или не-JSON ответе:** уровень warning, превью ответа (до 300 символов).
- **После успешного разбора:** уровень info — `amount`, `date`, `confidence`, флаг `valid`, длина переданного текста.
- **При исключении:** уровень error — сообщение и длина превью текста (без самого текста).

Превью текста чека в запросе к LLM ограничено константой (например, 2000 символов) при необходимости дополнительного логирования — в коде используется ограничение длины для отправки в API (6000 символов).

---

## 8. Выбор метода в интерфейсе и API

- В админке (страница настроек розыгрыша) в блоке «Метод определения суммы и даты из чеков» доступны три варианта; третий — **«Интеллектуальный (улучшенный + AI при низкой уверенности)»** с значением `enhanced_ai`.
- Сохраняемое значение попадает в `bot_settings.receipt_parser_method` и в API валидируется как `legacy` | `enhanced` | `enhanced_ai`.
- Константы в коде: `BotSettings::PARSER_LEGACY`, `BotSettings::PARSER_ENHANCED`, `BotSettings::PARSER_ENHANCED_AI`.

---

## 9. Краткая сводка

| Вопрос | Ответ |
|--------|--------|
| Где реализован метод? | `app/Services/Receipt/AIReceiptExtractor.php`, DTO — `AIReceiptExtractorResult.php` |
| Когда вызывается? | Только при методе `enhanced_ai` и (confidence &lt; 0.9 или нет суммы/даты); при этом `receipt_ai.enabled` и заданы URL + API key |
| Что отправляется в LLM? | System prompt + user prompt с подставленным текстом чека (до 6000 символов) |
| В каком формате ответ? | Один JSON-объект с полями `amount`, `date`, `currency`, `confidence` |
| Когда результат AI принимается? | После валидации суммы и даты и при `confidence >= 0.85` (`isValid()`) |
| Как отключить? | `RECEIPT_AI_ENABLED=false` или не задавать `OPENAI_API_KEY`; либо выбрать метод «Классический»/«Улучшенный» для бота |

Документ описывает только интеллектуальный метод и использование LLM; общая архитектура парсинга чеков и настройка банков — в других файлах проекта (например, `docs/RECEIPT_PARSER_IMPROVEMENTS.md`, `docs/BANK_CHECKS_CONFIG.md`).
