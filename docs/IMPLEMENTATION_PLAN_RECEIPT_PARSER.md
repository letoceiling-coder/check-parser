# План внедрения улучшений парсера чеков (сумма и дата)

Порядок: от быстрых и высокоэффективных к более объёмным. После каждой фазы — коммит и проверка на реальных чеках.

---

## Фаза 1. Текстовый PDF (pdftotext)

**Цель:** Для PDF с настоящим текстом не вызывать OCR — извлекать текст через `pdftotext` и парсить текущим `parsePaymentAmount()`. Максимальная точность для «цифровых» чеков.

### Зависимости
- На сервере: пакет **poppler-utils** (содержит `pdftotext`).
  - Ubuntu/Debian: `apt-get install poppler-utils`
  - Проверка: `pdftotext -v`

### Шаги

| # | Действие | Файл / место |
|---|----------|---------------|
| 1.1 | Добавить метод `extractTextFromTextPdf(string $pdfPath): ?string` | `TelegramWebhookController.php` |
| | В методе: вызвать `pdftotext -layout -enc UTF-8 <pdf> -`, прочитать stdout. При отсутствии `pdftotext` или ошибке возвращать `null`. | |
| 1.2 | В `processCheckWithOCR()` при `$isPdf === true`: **до** `convertPdfToImage()` вызвать `extractTextFromTextPdf($fullPath)`. | `TelegramWebhookController.php` (~стр. 1160) |
| | Если текст не пустой и длина ≥ 100 символов — считать его «достаточным», парсить через `parsePaymentAmount($text)`, в `checkData` добавить `'ocr_method' => 'pdftotext'`, вернуть результат **без** конвертации в картинку и OCR. | |
| 1.3 | Если текстовый текст пустой или короткий — вести себя как сейчас: `convertPdfToImage()` → OCR. | Тот же блок |
| 1.4 | Логировать: `Log::info('Text PDF extracted', ['length' => ..., 'used_pdftotext' => true])` при успешном извлечении через pdftotext. | |

### Критерии приёмки
- PDF с текстовым слоем: сумма и дата определяются без Tesseract.
- PDF-скан без текста: по-прежнему идёт в `convertPdfToImage` + OCR.
- В логах видно, когда использован `pdftotext`, когда OCR.

### Риски и обход
- На Windows (локальная разработка) `pdftotext` может отсутствовать — при `null` от `extractTextFromTextPdf` логика падает в текущий OCR, ничего не ломается.

---

## Фаза 2. Дата по контексту

**Цель:** Собирать все кандидаты дат, оценивать по позиции и контексту («дата», «время», HH:MM), выбирать лучшего — меньше путаницы с датой операции и датой в подвале.

### Шаги

| # | Действие | Файл / место |
|---|----------|---------------|
| 2.1 | В `parsePaymentAmount()` после блока с русскими месяцами добавить новый блок «дата по контексту». | `TelegramWebhookController.php`, ~после 2615 |
| 2.2 | Найти **все** вхождения дат одним regex: `\d{1,2}[./-]\d{1,2}[./-]\d{2,4}` (при необходимости расширить под пробелы). Для каждого сохранять: позицию в тексте (offset или номер символа), саму подстроку, нормализованную дату (YYYY-MM-DD). | |
| 2.3 | Для каждого кандидата считать балл: | |
| | +2 — в первой четверти текста (offset < 0.25 * strlen($text)); | |
| | +2 — в подстроке рядом (например, 50 символов) есть слова «дата», «время», «операции», «чек» (регистронезависимо); | |
| | +1 — рядом (в пределах 20 символов) есть время HH:MM или HH:MM:SS. | |
| 2.4 | Валидация: день 1–31, месяц 1–12, год в разумных пределах (например 2018–2031). Невалидные отбрасывать. | |
| 2.5 | Выбрать кандидата с максимальным баллом. Если балл совпадает — приоритет «раньше в тексте». Присвоить `$date`. | |
| 2.6 | Существующую логику «числовой формат первым» можно оставить как быстрый путь: если уже нашли дату числовым паттерном в начале — можно не запускать контекстный поиск (опционально, для скорости). | |

### Критерии приёмки
- В чеках с несколькими датами выбирается дата операции (вверху / рядом с «дата»/«время»), а не дата в подвале.
- Существующие кейсы (одна дата, русский месяц) продолжают работать.

---

## Фаза 3. Сумма: маркеры «оплачено» / «списано»

**Цель:** Добавить в ключевые слова и паттерны «оплачено», «списано» — как для «итого»/«сумма». Быстро и полезно для разных банков.

### Шаги

| # | Действие | Файл / место |
|---|----------|---------------|
| 3.1 | В массиве `$keywords` (скоринг) добавить: `'оплачено', 'списано'`. | `TelegramWebhookController.php`, parsePaymentAmount, ~стр. 2668 |
| 3.2 | В `$directPatterns` добавить 2–4 паттерна: | |
| | `'/оплачено[^\d]{0,30}' . $amountRegex . '\s*(?:руб\.?|' . $currencyPattern . ')?/ui'`, | |
| | `'/списано[^\d]{0,30}' . $amountRegex . '\s*(?:руб\.?|' . $currencyPattern . ')?/ui'`. | |
| 3.3 | В `$keywordPatterns` (блок «без символа валюты») добавить: | |
| | `'/оплачено[^\d]{0,30}' . $amountRegex . '/ui'`, | |
| | `'/списано[^\d]{0,30}' . $amountRegex . '/ui'`. | |

### Критерии приёмки
- Чеки с формулировками «Оплачено 1 500 ₽», «Списано 10 000 руб» распознают сумму корректно.
- Существующие паттерны («итого», «сумма») не затронуты.

---

## Фаза 4. Confidence и флаг «требует проверки»

**Цель:** Парсер возвращает оценку уверенности 0–1; при низкой — в БД и/или админке помечать чек как «требует проверки».

### 4.1 Расчёт confidence в парсере

| # | Действие | Файл / место |
|---|----------|---------------|
| 4.1.1 | В `parsePaymentAmount()` ввести переменные: `$confidenceDate = 0.0`, `$confidenceAmount = 0.0`. | `TelegramWebhookController.php` |
| 4.1.2 | Когда дата найдена: | |
| | +0.4 если по контексту (первая четверть текста / рядом «дата»/«время»/HH:MM); | |
| | +0.2 если одна-единственная валидная дата в тексте. | |
| 4.1.3 | Когда сумма найдена: | |
| | +0.4 если по ключевому слову (итого/сумма/оплачено/списано и т.д.); | |
| | +0.2 если только один сильный кандидат суммы. | |
| 4.1.4 | Итоговый confidence: `min(1.0, $confidenceDate + $confidenceAmount)`. Если несколько кандидатов даты или суммы — умножать на 0.85 (или уменьшать сумму на 0.15). | |
| 4.1.5 | В возвращаемом массиве добавить ключ `'parsing_confidence' => round($confidence, 2)`. Возвращать его и при `null` (например 0.0), чтобы вызывающий код всегда видел поле. | |

### 4.2 БД и модель

| # | Действие | Файл / место |
|---|----------|---------------|
| 4.2.1 | Создать миграцию: добавить в таблицу `checks` поле `parsing_confidence` (float, nullable) и при необходимости `needs_review` (boolean, default false). | `database/migrations/xxxx_add_parsing_confidence_to_checks_table.php` |
| 4.2.2 | В модели `Check`: добавить `parsing_confidence` и `needs_review` в `$fillable` и при необходимости в `$casts`. | `app/Models/Check.php` |

### 4.3 Сохранение при создании чека

| # | Действие | Файл / место |
|---|----------|---------------|
| 4.3.1 | Везде, где из `parsePaymentAmount()` или из `processCheckWithOCR()` берётся `$checkData` и создаётся/обновляется запись Check, передавать в модель `parsing_confidence` и выставлять `needs_review = true` при `parsing_confidence < 0.7` (порог настраиваемый). | `TelegramWebhookController.php`: saveCheckToDatabase, handleRaffleCheck, handleDocument, handlePhoto и т.д. |

### 4.4 Админка

| # | Действие | Файл / место |
|---|----------|---------------|
| 4.4.1 | API: в ответах списка/детали чека добавить поля `parsing_confidence` и `needs_review`. | `app/Http/Controllers/Api/CheckController.php` |
| 4.4.2 | Frontend: в списке чеков показывать бейдж «Требует проверки» при `needs_review === true`; на странице чека показывать «Уверенность распознавания: X%» (parsing_confidence * 100). | `frontend/src/pages/Checks.js`, `CheckDetails.js` |
| 4.4.3 | (Опционально) Фильтр в списке: «Только требующие проверки». | `frontend/src/pages/Checks.js` |

### Критерии приёмки
- В ответе парсера есть `parsing_confidence`.
- В БД чек сохраняется с `parsing_confidence` и при низком значении — с `needs_review`.
- В админке видно, какие чеки помечены как «требует проверки», и отображается уверенность.

---

## Порядок выполнения и оценка

| Фаза | Оценка по времени | Зависимости |
|------|-------------------|-------------|
| 1. Текстовый PDF | 1–2 ч | poppler-utils на сервере |
| 2. Дата по контексту | 2–3 ч | Нет |
| 3. «Оплачено»/«Списано» | ~30 мин | Нет |
| 4. Confidence + БД + админка | 2–3 ч | Миграция, фронт |

Рекомендуемый порядок: **3 → 1 → 2 → 4** (сначала быстрый выигрыш по сумме, затем текстовый PDF, затем улучшение даты, затем confidence и админка).

---

## Чек-лист перед релизом

- [ ] На проде установлен `poppler-utils` (для Фазы 1).
- [ ] Миграция для `parsing_confidence`/`needs_review` выполнена (Фаза 4).
- [ ] Проверены 3–5 реальных чеков (разные банки, текст и скан) после каждой фазы.
- [ ] Логи не засоряются лишними debug-сообщениями (оставить только нужные для отладки парсера).

После выполнения плана имеет смысл обновить `docs/RECEIPT_PARSER_IMPROVEMENTS.md`: отметить внедрённые пункты и при необходимости добавить банк-специфику и предобработку по мере появления проблем.
